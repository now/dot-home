#! @ZSHELL@

application=$(basename $0)

die () {
  print -r -- $application: $*
  exit 1
}

usage () {
  print -r -- "Usage: $application [-n] [-i] DIRECTORY ID"
  exit 1
}

xml () {
  print -r $1 | ruby -e 'require "nokogiri"; print Nokogiri::XML($stdin).xpath(ARGV[0]).map(&:text).join("\0")' $2
}

xml-array () {
  # NOTE: Due to a bug in Zsh < 4.3.13, 0 retains an empty string when "$(…)"
  # doesn’t generate any output.  Splitting it like this works around the
  # problem.
  local result="$(xml $2 $3)"
  set -A $1 ${(0)result}
}

xml-array-with-substituted-marks () {
  xml-array $1 $2 $3
  substitute-marks-array $1
}

substitute-marks-array () {
  local -a result
  for e in ${(P)1}; do
    result+=$(substitute-marks $e)
  done
  set -A $1 $result
}

substitute-marks () {
  print -r -- ${${${*//\'/’}//(#b)\"([^\"]#)\"/“$match[1]”}/\"/″}
}

xml-artist-array () {
  xml-array-with-substituted-marks $1 $2 $3/name
  if (( ${#${(P@)1}} > 1 )); then
    set -A $1 "$(substitute-marks "$(join-artist $3)")" ${(P)1}
  fi
}

join-artist () {
  print -r -- ${(j: :)${(0)"$(xml $release "$1/name|$1/join")"}}
}

clean-name () {
  local -a match mbegin mend

  print -r -- ${${${${${${${${(L):-$*}//[\/]/-}//(#b)[[:space:]]#\(([^\)]#)\)/-$match[1]}/ & / and }/&/ and }// /_}//[?!]}//.../…}
}

differentimages=0
local -A images
xml-image () {
  local uri=
  case $2 in
    (primary)
      uri=$(xml $1 "(/resp/release/images/image[@type='primary'])[1]/@uri")
      [[ -z $uri ]] && uri=$(xml $1 '/resp/release/images/image[1]/@uri')
      ;;
    (secondary)
      uri=$(xml $1 "(/resp/release/images/image[@type='secondary' and preceding-sibling::image[1][@type='primary']])[1]/@uri")
      ;;
  esac
  if [[ -n $uri ]]; then
    local image=; image=$(mktemp dti.XXXXXX) || exit 1
    trap 'rm -f $images; exit 130' INT
    trap 'rm -f $images; exit 143' TERM
    curl -L --compressed --silent --show-error $uri > $image || { rm -f $image; exit 1 }
    local format=; format=$(identify -format %m $image) || exit 1
    if [[ format != (JPEG|PNG) ]]; then
      local jpeg=; jpeg=$(mktemp dti.jpeg.XXXXXX) || { rm -f $image; exit 1 }
      convert $image jpg:- > $jpeg || { rm -f $image $jpeg; exit 1 }
      rm -f $image
      image=$jpeg
    fi
    images[$2]=$image
  elif [[ $2 = primary ]]; then
    die 'missing primary image; upload one'
  fi
}

precmd=
checkcount=1
checkpositions=1

while :; do
  case $1 in
    (-n)
      precmd='print -r --'
      ;;
    (-i)
      differentimages=1
      ;;
    (-c)
      checkcount=0
      ;;
    (-p)
      checkpositions=0
      ;;
    (--)
      break
      ;;
    (-*)
      die 'invalid option: ' $1
      ;;
    (*)
      break;;
  esac
  shift
done

(( $# == 2 )) || usage
directory=$1
[[ -d $directory ]] || die 'no such file or directory: ' $directory
id=${2/http:\/\/(www.|)discogs.com\/([^\/]##\/|)release\/}
release=$(curl --compressed --silent --header 'Accept: application/xml' http://api.discogs.com/release/$id)
error=$(xml $release '/resp/error')
if [[ -n $error ]]; then
  die $error
fi

xml-artist-array albumartists $release /resp/release/artists/artist
album=$(substitute-marks $(xml $release /resp/release/title))
xml-array-with-substituted-marks labels $release /resp/release/labels/label/@name
xml-array catalognumbers $release /resp/release/labels/label/@catno
released=$(xml $release /resp/release/released)
location=$(xml $release /resp/release/country)
xml-array genres $release /resp/release/styles/style
xml-array positions $release /resp/release/tracklist/track/position
xml-array-with-substituted-marks titles $release '/resp/release/tracklist/track[position!=""]/title'
xml-image $release primary
(( differentimages )) && xml-image $release secondary

files=($directory/*.flac(Nn))
if (( checkcount && $#files != $#positions )); then
  die $(printf 'number of files in directory doesn’t match number of tracks at Discogs: %d != %d: %s: %s' $#files $#positions $directory http://www.discogs.com/release/$id)
fi

if (( checkpositions )); then
  illegalpositions=${positions:#[A-Za-z]([1-9][0-9]#|)}
  if (( $#illegalpositions > 0 )); then
    die $(printf 'some track positions don’t contain side information on Discogs: %s: %s' $position http://www.discogs.com/release/$id $illegalpositions)
  fi

  for (( i = 1; i <= $#files; i++ )); do
    local pos=${${${${${files[i]}:t:r}##[0-9][0-9][0-9][0-9]##-}/-0}/-}
    if [[ $pos != (#i)$positions[i] ]] &&
       { [[ $pos != (#i)[a-z] ]] || [[ ${pos}1 != (#i)$positions[i] ]] }; then
      die $(printf 'track position of file doesn’t match that of track on Discogs: %s !~ %s: %s: %s' $pos $positions[i] $files[i] http://www.discogs.com/release/$id)
    fi
  done
fi

# TODO: Allow user to set COMMENT?
# TODO: Allow user to set INITIALKEY?
# TODO: Allow user to set RATING WMP?
#
# TODO: SOURCEMEDIA=/resp/release/formats/format/@name|/resp/release/formats/format/descriptions/description
#
# NOTE: Traktor uses YEAR for the Released field, but, of course, only the year
# part.
# TODO: We could have used DISCNUMBER+TRACKNUMBER to convert A1 to 1+1, but
# Traktor doesn’t support DISCNUMBER.
[[ -n $(xml $release /resp/release/tracklist/track/artists/artist/name) ]] && trackartists=y
if [[ -z $trackartists ]]; then
  artists=($albumartists)
  albumartists=()
fi
nmdbid=${${directory:t}%%[^0-9]*}
local -a mixartists
xml-artist-array mixartists $release "/resp/release/extraartists/artist[role='Remix' or role='Edited By']"
[[ -n $(xml $release "/resp/release/tracklist/track/extraartists/artist[role='Remix' or role='Edited By']/name") ]] && trackmixartists=y
for (( i = 1; i <= $#files; i++ )); do
  if [[ -n $trackartists ]]; then
    xml-artist-array artists $release "/resp/release/tracklist/track[position='$positions[i]']/artists/artist"
    if (( $#artists == 0 )); then
      artists=($albumartists)
    fi
  fi
  if [[ -n $trackmixartists ]]; then
    xml-artist-array mixartists $release "/resp/release/tracklist/track[position='$positions[i]']/extraartists/artist[role='Remix' or role='Edited By']"
  fi
  local image=
  (( differentimages )) && [[ $positions[i] != [aA]* ]] && image=$images[secondary]
  [[ -z $image ]] && image=$images[primary]
  $=precmd metaflac \
    --remove-tag=ALBUMARTIST \
    --remove-tag=ALBUM \
    --remove-tag=ORGANIZATION \
    --remove-tag=CATALOGNUMBER \
    --remove-tag=DATE \
    --remove-tag=YEAR \
    --remove-tag=LOCATION \
    --remove-tag=GENRE \
    --remove-tag=TRACKNUMBER \
    --remove-tag=POSITION \
    --remove-tag=ARTIST \
    --remove-tag=TITLE \
    --remove-tag=MIXARTIST \
    --remove-tag="DISCOGS RELEASE ID" \
    --remove-tag="NMDB ID" \
    --add-replay-gain \
    --set-tag=ALBUMARTIST=${^albumartists} \
    --set-tag=ALBUM=$album \
    --set-tag=ORGANIZATION=${^labels} \
    --set-tag=CATALOGNUMBER=${^catalognumbers} \
    --set-tag=DATE=$released \
    --set-tag=YEAR=$released \
    --set-tag=LOCATION=$location \
    --set-tag=GENRE=${^genres} \
    --set-tag=TRACKNUMBER=$i \
    --set-tag=POSITION=$positions[i] \
    --set-tag=ARTIST=${^artists} \
    --set-tag=TITLE=$titles[i] \
    --set-tag=MIXARTIST=${^mixartists} \
    --set-tag="DISCOGS RELEASE ID=$id" \
    --set-tag="NMDB ID=$nmdbid" \
    ${image:+--import-picture-from=$image} \
    $files[i]
  local flac=$files[i]:h/$(clean-name $positions[i]-${trackartists:+$artists[1]-}$titles[i]).flac
  [[ $files[i] -ef $flac ]] || $=precmd mv $files[i] $flac
done
local fulldirectory=$directory:h/$nmdbid-$(clean-name ${albumartists[1]:-$artists[1]}-$album)
[[ $directory -ef $fulldirectory ]] || $=precmd mv $directory $fulldirectory
rm -f $images
