#! @ZSHELL@
# contents: Memory map analyzer.
#
# Copyright © 2008 Nikolai Weibull <now@bitwi.se>

autoload -U zap/init
zap/init $0:t '1.0.0'

autoload -U zap/math



local optdesc
optdesc=(
  ""  ""        ' [PID...]'                                         ""  0 0 -1
  ""  ""        'Display process memory map information.'           ""  0 0 -1
  ""  'PID'     'process id of process to process'                  ""  0 0 0
)

REGEX="^\([0-9a-f]\+\)-\([0-9a-f]\+\) \([r-][w-][x-]\)[ps] [0-9a-f]\+ \
\([0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]\) [0-9]\+ \+.*$"



# We used to have
#
# sed -n "s/$REGEX/(( \4[\3] += (0x\2 - 0x\1) \/ 1024 ));/p" /proc/$1/maps |
#
# in the command below, but Zsh can’t handle arithmetic with 64-bit adresses.
process-map () {
  local -A mapped
  local -A unmapped

  eval $(
    sed -n "s/$REGEX/(( \4[\3] += \$({echo 'ibase = 16;'; echo '(\2 - \1)' | tr \\\[a-f\\\] \\\[A-F\\\]} | bc) ));/p" /proc/$1/maps |
    sed "s/^(( 00:00/(( unmapped/;s/^(( ..:../(( mapped/"
  )

  print-data $1
}

declare -a number_sizes
number_sizes=(
  ""
  "K"
  "M"
  "G"
  "P"
)

format-number () {
  float n="$1"
  integer size=1
  while (( n > 1000 )); do
    (( n /= 1000 ))
    (( size++ ))
  done
  # TODO: Check that size isn’t beyond end of number_sizes
  local format
  if (( n > 100 )); then
    format='0'
  elif (( n > 10 )); then
    format='0'
  elif (( n > 1 )); then
    format='1'
  elif (( n > 0 )); then
    format='2'
  else
    format='0'
  fi
  local prefix
  if (( size == 1 )); then
    prefix=" "
  fi
  printf "  $prefix%3.${format}f%s" $n $number_sizes[size]
}

#largest-of-modes () {
#  integer accounted_for
#  for mode in ${*[2,-1]}; do
#    integer m=${${(P)1}[$mode]:-0}
#    (( largest = max(largest, m) ))
#    (( accounted_for += m ))
#  done
#  (( largest = max(largest, ${(Pvj:+:)1:-0} - accounted_for) ))
#  (( largest_$1 = largest ))
#}

print-data () {
#  integer largest_mapped largest_unmapped width
#  largest-of-modes mapped r-x r-- rw-
#  largest-of-modes unmapped rwx rw- r-- ---
#  (( width = ${#"$(format-number $(( max(largest_mapped, largest_unmapped) )))"} ))

  if (( !printed_header )); then
    print 'PID    Backed by file            Unmapped'
    print '         Exec  RO    RW    ?       Stack Heap  RO    No R  ?   '
    (( printed_header = true ))
  fi

  printf "%-5d  " $1
  format-number ${mapped[r-x]:-0}
  format-number ${mapped[r--]:-0}
  format-number ${mapped[rw-]:-0}
  format-number $((${(vj:+:)mapped:-0}))
  print -n "  "
  format-number ${unmapped[rwx]:-0}
  format-number ${unmapped[rw-]:-0}
  format-number ${unmapped[r--]:-0}
  format-number ${unmapped[---]:-0}
  format-number $((${(vj:+:)unmapped:-0}))
  print
}



zap/parse-options optdesc $*
if (( $#ZAP_ARGUMENTS == 0 )); then
  zap/error 1 "missing pid argument"
else
  integer printed_header
  for pid in $ZAP_ARGUMENTS; do
    if [[ $pid != <1-65535> ]]; then
      zap/error 1 "illegal pid (not a number in range 1..65535):" \
        "    pid: $pid"
    elif [[ ! -d /proc/$arg ]]; then
      zap/error 1 "can't access memory map (no such process):" "    pid: $pid"
    elif [[ ! -e /proc/$arg/maps ]]; then
      zap/error "can't access memory map (no such file):" \
        "    file: /proc/$pid/maps"
    else
      process-map $pid
    fi
  done
fi
